# 1. vite为什么快？这种快的机制会不会有什么问题？官方是如何解决的？

在上一小节我们知道，vite的开发时构建速度要远远地超过了webpack,那么为什么会这样呢？想要搞明白这个问题我们就必须要弄清楚webpack的开发时构健策路以及vte的开发时构建策略。

## vite为什么快？

### webpack

- 在中运行项目时，会默认会去抓取并构建你的整个应用，然后才能提供服务；存在的任何一个错误，它依然会形响到你的整个项目构理；也正是因为这个原因，当你的项目应大时，构建的时间就会越长，你的项目启动速度也航会越慢。

### vite

- vite不会在一开始就构建整个项目，而是会将应用中的模块区分为**依赖**和**源码**两部分。它会根据路由来拆分代码模块，只会去构建一开始就必须要构建的内容；

- 同时vite以原生ESM的方式为浏览器提供源码，让刘览器接管了打包的部分工作。因为这样的一个机制，无论你的项目有多大，它只会构建一开始必须要构建的内容，这就让1t在构建时的速度大大提升了。

## vite的快会有什么问题呢？

如果对ESM的构建机制有了解的话，那么应该可以发现一个问题。

那就是vite既然以原生ESM的方式为浏览器提供源码，让浏览器接管了打包的部分工作，那么假如我们的项日中存在commonJS的内容味着无法解析。

在vite的早期版本中，确实存在这个问题，这个问题导致的最核心的麻烦就是很多的依赖无法使用。
比如axios因为axios中使用了很多的commonJS规范，这就让vite无法解析对应的内容，从而会抛出一个错
误，关丁这个问题曾经也在ite的issues中法行过数烈的讨论。

### 官方解决方案

vite后期版本中提供了[依赖预构建](http://www.vitejs.net/guide/dep-pre-bundling.html) 的功能，解决CommonJS和UMD兼容性问题。目前vite会先将CommonJS或UMD 发布的依赖项转换为ESM后，再重新进行编译。